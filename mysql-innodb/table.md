# 表

## 索引组织表

InnoDB 存储引擎中，表都是根据主键顺序组织存放的。也称索引组织表（index organized table）。其中主键的选择和创建：

1. 先判断是否有非空的唯一索引，如果有则该列即为主键
2. 若没有，InnoDB会自动创建一个6字节大小的指针
3. 若存在多个非空的唯一索引，则InnoDB选择第一个定义的非空唯一索引为主键，与列的定义顺序无关。

## 逻辑存储结构

所有数据都被逻辑地存放在一个空间，表空间（tablespace）。其包含段（segment）、区（extent）、页（page）。

## 约束

InnoDB 提供5中约束： Primary Key, Unique Key, Foreign Key, Default, NOT NULL

约束同索引，有关系却不同，创建索引时也对应了一种约束，约束是逻辑上的概念，索引则是一种数据结构。

触发器可以在执行 INSERT、DELETE和UPDATE命令之前或之后自动调用的SQL命令或存储过程。一张表最多创建6个触发器。

外键约束，在父表删除更新时，字表有4种级别操作：CASCADE, SET NULL, NO ACTION, RESTRICT

## 视图

视图可以理解为基于基表的虚拟表。

## 分区表

分区类型分为：RANGE分区，LIST分区，HASH分区，KEY分区，COLUMNS分区（支持非整型数据）

子分区也称复合分区，是在RANGE或LIST分区基础上在进行HASH或KEY分区。

不同分区类型对于NULL的定义和操作不同。

分区和性能不一定正相关。要根据实际情况进行分区。因为对于大表查询，B+树需要2-3次磁盘IO。而基于主键分区之后，分两类情况：1，针对主键的查询，可能B+树高度会降低，即少一次磁盘IO。从而提高了查询效率。2，针对非主键查询的请求，查询需要扫描所有N个分区。即使每个分区2次IO。也需要2*N次IO请求，必然大于原本未分区时，相同请求所对应的2-3次IO。因而并非分区就可以提高性能。需要分区时，需评估数据的访问模式。
