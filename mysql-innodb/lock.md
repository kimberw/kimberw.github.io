# 锁

多用户、数据库驱动开发最大的难点是：1，如何最大程度的利用并发访问。2，如何确保每一个用户能一直的读取和修改数据。因此有了锁机制（locking）。

## lock与latch

### latch

其锁定时间非常短，可以分为 mutex 和 rwlock，用来保证并发线程操作临界资源的正确性。并且通常没有死锁检测机制。

### lock

对象是事务，用来锁定的是数据库中的对象。如表，页，行。一般在事务commit或rollback时释放。具有死锁机制。

|          |                             lock                             |                            latch                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   对象   |                             事务                             |                             线程                             |
|   保护   |                          数据库内容                          |                         内存数据结构                         |
| 持续时间 |                         整个事务过程                         |                           临界资源                           |
|   模式   |                      行锁、表锁、意向锁                      |                        读写锁、互斥量                        |
|   死锁   | 通过 waits-for graph、 time out等机制进行无死锁检测与处理机制。 | 无死锁检测与处理机制。仅通过应用程序加锁的顺序( lock leveling )保证无死锁的情况发生 |
|  存在于  |                    Lock Manager的哈希表中                    |                     每个数据结构的对象中                     |

## InnoDB存储引擎中的锁

### 锁类型

InnoDB 存在两种标准的行级锁：

- 共享锁 S Lock 允许事务读一行数据
- 排他锁 X Lock 允许事务删除或更新一行数据

S X 锁兼容性

|      |   S    |   X    |
| :--: | :----: | :----: |
|  S   |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 |

InnoDB 支持多粒度（granular）锁，该锁允许行级和表级锁同时存在。InnoDB为了支持在不同粒度加锁的行为，采用一种额外的锁，意向锁（Intention Lock）。意向锁将锁定的对象分为多个层次，意味着事务可以在更细粒度上进行加锁。

InnoDB 支持两种意向锁：

- 意向共享锁（IS Lock），事务想要获取一张表中某几行的共享锁
- 意向排他锁（IX Lock），事务想要获取一张表中某几行的排他锁

表级意向锁与行级锁兼容性：

|      |   IS   |   IX   |   S    |   X    |
| :--: | :----: | :----: | :----: | :----: |
|  IS  |  兼容  |  兼容  |  兼容  | 不兼容 |
|  IX  |  兼容  |  兼容  | 不兼容 | 不兼容 |
|  S   |  兼容  | 不兼容 |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |

### 一致性非锁定读

指InnoDB通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。若该行正在执行UPDATE 或 DELETE 则会读取当前行的快照数据。该方法避免了读取数据时需等待X锁的问题。极大的提高了数据库的并发性。

快照数据是有undo段完成的，undo本就是用在事务回滚数据的。所以快照数据本身没有额外开销。快照数据不需要上锁，因为没有事务会对历史数据进行修改。

InnoDB默认的数据读取方式。但是不同事务隔离级别下读取方式有差别，而且对快照数据的定义也不相同。一行数据不止有一个快照数据，称行多版本技术，由此带来的并发控制称为多版本并发控制（Multi Version Concurrency Control， MVCC）。

InnoDB在READ COMMITTED 和 REPEATABLE READ下使用非锁定一致性读。READ COMMITED下总是读取最新一份快照数据。而REPEATABLE READ下，非一致性读总是读取事务开始时的行数据版本。

### 一致性锁定读

- SELECT……FOR UPDATE 会对读取的行记录加一个X锁
- SELECT……LOCK IN SHARE MODE 会对读取的行记录加一个S锁

### 自增长与锁

含有自增长值得表都有一个自增长计数器（auto-increment counter）。插入操作会根据这个自增长的计数器加1赋予自增长列，AUTO-INC Locking。这种锁其实是一种特殊的表锁机制。为了提高性能，该锁在完成自增长值插入的sql语句后立即释放。

但是这种性能仍旧不高，原因是：对于批量插入语句而言，下一个插入操作需要等待前一次插入操作完成后才可以进行，否则阻塞。这里将插入分为几个类型：

- insert-like 所有插入
- simple inserts 在插入前就可以确定插入行数的语句。
- bulk insers 在插入前无法确定插入行数的语句
- mixed-mode inserts 混合模式表示既有自增长的，又有定值的混合插入语句。



| 参数innodb_autoinc_lock_mode |                             说明                             |
| :--------------------------: | :----------------------------------------------------------: |
|              0               |                 旧版本的AUTO-INC Locking方式                 |
|              1               | 默认值，对于simple inserts，采用互斥量（mutex）对内存中的计数器进行累加操作，对于bulk inserts使用AUTO-INC Locking方式。 |
|              2               | 对于所有 insert-like自增值得产生都通过互斥量。此方式新能最高。此时若采用Statement-Base Replication会出现问题。应该采用row-base replication。才能保证最大的并发性能及replication 主从数据的一致。 |

### 外键和锁

InnoDB 对于外键列会自动加一个索引，避免表锁，从而产生死锁。对于外键值得插入，SELECT父表时采用的不是一致性非锁定读。而是 SELECT……LOCK IN SHARE MODE。避免出现数据在父表，子表中存在不一致的情况。

## 锁算法

### 行锁的3种算法：

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，单不包含记录本身
- Next-Key Lock： Gap Lock + Record Lock 锁定一个范围，并锁定记录本身

InnoDB 采用 Next-Key Locking 的目的是为了解决 Phantom Promblem。当查询的索引含有唯一属性时，InnoDB 将 Next-Key Locking 优化降级为 Record Lock。该操作仅对聚集索引有效。对于辅助索引，不仅需要加上 Next-Key Lock 还会对下一个键值加 Gap Lock。

用户可以通过两种方式关闭 Gap Lock，仅在外键约束和唯一性检查时才需要 Gap Lock：

- 将事务的隔离级别设置为 READ COMMITTED
- 将参数 innodb_locks_unsafe_for_binlog 设置为1

READ COMMITTED 破坏了事务的隔离性，对于 replication 可能导致主从数据不一致。从性能上看，也不会优于默认的 REPEATABLE READ。

对于唯一索引由多列组成的情况，查询仅是查找多个唯一索引列中的一个，是range类型查询，而非point类型查询。所以 InnoDB 依然会使用 Next-Key Lock 进行锁定。

### 解决 Phantom Problem

幻读是指在同一事物下，连续两次执行同样的SQL 语句可能导致不同的结果。第二次的SQL可能会返回之前不存在的行。InnoDB 通过 REPEATABLE READ下的 Next-Key Locking 来解决幻读问题。

## 锁问题

|            | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读取到另一个事务还未提交的数据                       |
| 不可重复读 | 一个事务内两次读取的数据不一致。                             |
| 幻读       | 部分书中提到的一种方式：指操作全表数据时，出现不符合预期的数据，像出现幻觉一样。在mysql官方文档中将其定义为不可重复读的一种。 |

## 阻塞

InnoBD 不会回滚超时引发的错误异常。

## 死锁

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。

解决死锁的方法：

- 超时，最简单。
- wait-for graph 等待图，主动的死锁检测方式。要求数据库保存1，锁的信息链表，2，事务的等待链表

wait-for graph 是一个种较为主动的死锁检测机制。在每个事务请求锁并发生等待时，都会判断是否存在回路。若存在则有死锁，并回滚undo量最少的事务，即权重值最小的事务。死锁的检测算法采用深度优先的算法实现。

死锁发生的概率：

- 事务个数 n 越大死锁概率越大
- 每个事务操作的数量 r 越大死锁的概率越大
- 操作的数据集和 R 越小，死锁的概率越大

## 锁升级

Microsoft sql server 认为锁是一种稀有的资源，在合适的情况下，会将锁升级为更粗粒度的锁。从而保护系统资源。

InnoDB 不存在锁升级的问题，因为其锁的实现并非稀有资源。因为其不是根据每个记录来产生行锁的，而是根据每个事务访问的每个页对锁进行管理的，采用位图的形式。不论一个事务锁住页中一个还是多个记录，产生的开销通常都是一致的。

举例：一张表有3000000个数据页，每个页大约有100条记录。若事务执行全表更新操作。若根据每行记录产生锁对象，每个锁占用10字节。差不多需要3GB内存。而 InnoDB 根据页进行加锁，采用位图方式，每页占用30个字节。仅需90MB的内存。

