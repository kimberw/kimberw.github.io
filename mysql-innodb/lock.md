# 锁

多用户、数据库驱动开发最大的难点是：1，如何最大程度的利用并发访问。2，如何确保每一个用户能一直的读取和修改数据。因此有了锁机制（locking）。

## lock与latch

### latch

其锁定时间非常短，可以分为 mutex 和 rwlock，用来保证并发线程操作临界资源的正确性。并且通常没有死锁检测机制。

### lock

对象是事务，用来锁定的是数据库中的对象。如表，页，行。一般在事务commit或rollback时释放。具有死锁机制。

|          |                             lock                             |                            latch                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   对象   |                             事务                             |                             线程                             |
|   保护   |                          数据库内容                          |                         内存数据结构                         |
| 持续时间 |                         整个事务过程                         |                           临界资源                           |
|   模式   |                      行锁、表锁、意向锁                      |                        读写锁、互斥量                        |
|   死锁   | 通过 waits-for graph、 time out等机制进行无死锁检测与处理机制。 | 无死锁检测与处理机制。仅通过应用程序加锁的顺序( lock leveling )保证无死锁的情况发生 |
|  存在于  |                    Lock Manager的哈希表中                    |                     每个数据结构的对象中                     |

## InnoDB存储引擎中的锁

### 锁类型

InnoDB 存在两种标准的行级锁：

- 共享锁 S Lock 允许事务读一行数据
- 排他锁 X Lock 允许事务删除或更新一行数据

S X 锁兼容性

|      |   S    |   X    |
| :--: | :----: | :----: |
|  S   |  兼容  | 不兼容 |
|  X   | 不兼容 | 不兼容 |



## 锁算法

## 锁问题

## 阻塞

## 死锁

## 锁升级

