# 索引

## B+树

B+树 是一种平衡查找树，在B树的基础上做了优化（仅叶子节点存储数据）

为什么索引使用B+树呢，因为B+树同文件系统目录结构很相似，并且作为索引的B+树一般是2~4层，可以保证数据库操作效率。

对于索引添加或删除

- 聚集索引

  一张表只能有一个聚集索引，因为聚集索引的叶子节点是用来存放数据的。方便对于主键的排序查找和范围查找。

- 非聚集索引 辅助索引

  非聚集索引可以有多个，其叶子节点存放的是指向主键索引的主键的指针。InnoDB 通过辅助索引查询的过程是 先通过辅助索引查询到叶子节点，获取其对应的聚集索引的主键。在通过聚集索引进行查询找到对应的完整行信息。

对于索引添加或删除，mysql的操作是这样的

1. 首先创建一张新的临时表
2. 然后把原表中的数据导入到临时表
3. 删除原表
4. 临时表重命名为原表

意味着对一张大表进行索引添加或删除操作，会需要很长时间，若此时有大量事务访问该表，则会导致数据库服务不可用。这是mysql 区别于 microsoft sql server 或 oracle 的其中一点。

InnoDB 提供一种 Fast Index Creation 快速索引创建 FIC。即对于辅助索引的创建，InnoDB 存储引擎会对创建索引的表加上一个S锁。在创建过程中，不需要重建新表。删除索引只需更新内部视图，并将辅助索引空间标记为可用，同时删除mysql数据库内部视图对该表的索引定义即可。但是由于过程中对表加了S锁，导致在创建索引的过程中只允许进行读操作，此时写操作也是不可用的。FIC操作只能针对辅助索引的增删。对于主键索引则需要重新建表。

Online Schema Change 在线架构改变 OSC 最早由 Facebook 实现的一种在线执行DDL的方式。其实现过程做了些在线更改的优化，1，将原表数据写入新表过程中，为了减少对原表的锁定时间，通过分片将数据输出到多个外部文件的形式实现。 2，将操作过程中的DML操作记录应用到新表上。保证切换过程中的数据库可用性。不过其要求必须有主键，并且不能存在外键和触发器。同时会导致主从不一致问题。

mysql5.6 版本开始支持 Online DDL（在线数据定义）操作，大大提高了生产环境的可用性。其支持一下操作：

- 辅助索引的创建和删除
- 改变自增长值
- 添加或删除外键约束
- 列的重命名

其实现过程是：在执行创建或者删除操作的过程中，将 insert、update、delete这类的DML操作日志写入一个缓存中。待完成索引创建后再重做到表上。以达到数据的一致性。

## Cardinality值

表示索引中不重复记录数量的预估值，并非准确值。一般 Cardinality/n_rows_in_table 应尽可能的接近1，才适合创建索引。否则没有必要创建这个索引。

Cardinality 统计计算发生时机：

- 表中1/16的数据发生变化
- stat_modified_counter>2000000000

Cardinality 的计算方法:

1. 取得B+ 树索引中叶子节点的数量，记为A
2. 随机取B+树索引中的8个叶子节点，统计每个页不同记录的个数，即 P1，P2,……，P8
3. 根据采样信息给出 Cardinality 的预估值： Cardinality=（P1+P2+……+P8）*A/8

根据上面的计算方法可以知道，Cardinality 是一个预估值，对于超过8个叶子节点的表而言，每次计算的结果可能不同。小于8个节点的则一定相同。

在执行 ANALYZE TABLE、SHOW TABLE STATUS、SHOW INDEX 以及访问INFORMATION_SCHEMA 架构下的表TABLES 和 STATUISTICS 时会导致InnoDB存储引擎去重新计算Cardinality值。

## 索引的应用

### 联合索引

对表上多列进行索引。例如：联合索引（a,b），在查询 a 或者 a AND b时 均可使用该索引。但是查询 b 时不能使用该索引。

### 覆盖索引

即在辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。一般用在统计数据上。好处在于辅助索引不包含整行记录的索引信息，故其大小远小于聚集索引，这样可以减少IO操作。

### 优化器选择不使用索引

尽管使用辅助索引很大程度上会带来效率的提升，但是有时也会选择不使用辅助索引，而是聚集索引进行表扫描。主要取决于在通过辅助索引获取到的数据，变成大量离散化的磁盘读操作。优化器则会选择使用聚集索引查找数据。这样顺序读的效率可能比离散读快。

### 索引提示

mysql 支持索引提示（INDEX HINT），即显示的告诉优化器使用哪个索引。一般在以下情况使用：

- 优化器错误的选择了某个索引。dba强制优化器使用某索引。来提高性能。这种情况很少见。
- 某sql语句可以使用的索引非常多，优化器在选择执行计划时间的开销可能较大。此时强制优化器使用某索引减少了多各个执行路径的分析成本。

### Muti-Range Read 优化

MRR 优化目的是为了减少磁盘的随机访问，将随机转为顺序。对于缓冲池不是足够大的情况，频繁的离散读操作导致缓存中的页被替换出缓冲池，然后又不断的被读入缓冲池。MRR优化有一下几个好处：

- MRR使数据访问变成较为顺序的

- 减少缓冲池中页被替换的次数

- 批量处理对键值得查询操作

对于范围查询和join查询操作，MRR的工作方式：

1. 将查询得到的辅助索引键值放于一个缓存中，此时顺序是根据辅助索引键值排序的
2. 将缓存中的键值根据RowID进行排序
3. 根据RowID的排序顺序来访问实际的数据文件

### Index Condition Pushdown （ICP）优化

ICP也是mysql 5.6开始支持的一种根据索引进行查询的优化方式。在支持 ICP 之前，mysql进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录。在支持 ICP 之后，mysql 会在取出素银的同时，判断是否可以进行 where 条件过滤。将两个步骤合并在存储引擎层完成，减少了上层sql层对记录的索取，从而提高性能。

某测试结果显示：对于索引查询效率，ICP可以提高23%，同时开启MRR可以提升400%。

## 哈希算法

哈希可以保证数据定位的时间复杂度是O(1)。很好的解决了直接寻址时域较大的问题。但是会出现碰撞（collision）。在数据库中解决碰撞问题采用的是链接发（chaining）。

好的哈希函数可以减少碰撞发生的次数。一般来说，都将关键字转换成自然数，然后通过除法散列、乘法散列或全域散列来实现。数据库一般采用除法散列。

### InnoDB的哈希算法

冲突机制采用链表，哈希函数是除法散列，其m值会选择一个略大于2倍缓冲池页数量的质数。InnoDB存储引擎的表空间都有一个space_id每一个连续16K的页都有偏移量offset。关键值K=space_id<<20 + space_id+offset 

## 全文检索

InnoDB 1.2.x版本开始支持全文检索。

### 倒排索引（inverted index）

倒排索引同B+树索引一样也是一种索引结构。他在辅助表（auxiliary table）中存储了单词与单词吱声在一个或多个文档中所在位置之间的映射。一般有两种表现形式：

- inverted file index ： {单词，单词所在文档的ID}
- full inverted index ：{单词，(单词所在文档的ID，具体位置)}

### InnoDB 全文检索

InnoDB采用full inverted index 的方式。为了提高效率InnoDB存储引擎使用6张辅助表，按表word的Latin编码进行分区。

辅助表是一个持久的表，存放在磁盘上。同时还有一个FTS index Cache （全文检索索引缓存），用来提高检索的性能。

FTS Index Cache 是一个红黑树结构，根据（word，ilist）进行排序。在插入数据更新到对应表时，并不会立即更新全文检索相关数据结构。InnoDB会批量对辅助表进行更新。更新步骤为：首先会使用FTS Index Cache 中对应的 word 字段合并，然后再更新到辅助表中。类似 insert buffer的合并操作。

对于删除操作，在事务提交时，不删除磁盘辅助表中的数据，只删除FTS Index Cache中的记录，对于被删除的记录将其FTS Document ID保存在Deleted auxiliary table中。所以索引表会随时间逐渐增大，InnoDB提供用户手工将已删除的记录从索引中彻底删除的命令：OPTIMIZE TABLE。同时也可以设置分批删除的大小。

全文检索的限制：

- 每张表只能有一个全文检索的索引
- 由多列组合而成的全文索引的索引列必须使用相同的字符集与排序规则
- 不支持没有单词界定符的语言，如中文、日语、汉语等

